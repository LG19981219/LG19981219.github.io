<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[支付宝小程序之数据绑定和渲染]]></title>
    <url>%2F2019%2F07%2F05%2F%E6%94%AF%E4%BB%98%E5%AE%9D%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%92%8C%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[数据绑定支付宝小程序的数据绑定主要是通过获取每一个page的data对象，然后通过该表达式来动态的渲染页面的内容，下面做一个简单的示例。首先新建一个小程序的页面，在该页面的.axml写入&lt;view&gt;&lt;/view&gt;,这里的myName就是你所需要展示的数据。这时，再去该页面的js文件中新建data对象，data{myName : &quot;LG&quot;},保存，就可以在模拟器中看到我们自己定义的数据被渲染。 数据渲染数据渲染有条件渲染和for循环列表渲染两种 条件渲染条件渲染即满足条件才进行渲染，否则不进行渲染。基本格式为&lt;view a:if=&quot;&quot;&gt;内容&lt;/view&gt;,当flag为真时，内容才会被渲染，这里的flag可以写在data对象中，即通过数据绑定的方式传入true或false.条件渲染也可以通过运算结果进行判断，基本格式为&lt;view a:if=&quot;&quot;&gt;内容1&lt;/view&gt;&lt;view a:elif=&quot;&quot;&gt;内容二&lt;/view&gt;&lt;view a:elif=&quot;&quot;&gt;内容3&lt;/view&gt;条件1满足，显示内容1，条件2满足，显示内容2，否则显示内容3. for循环列表渲染for循环渲染主要是通过绑定data中的数组,在页面循环显示基本格式为&lt;view a:for=&quot;&quot; a:for-item=&quot;item&quot; a:for-index=&quot;index&quot;&gt;&lt;/view&gt;其中for-item为渲染的每一项，for-index为数组下标，这两项默认为item和index，当然你也可以自行更改。 view和block的区别在进行循环时，常用的外部容器为view和block，它两的在用法上没有区别，但是view相当于复制，而block则相当于直接在页面写内容。]]></content>
      <categories>
        <category>支付宝小程序</category>
      </categories>
      <tags>
        <tag>数据渲染和绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript基本类型及操作符]]></title>
    <url>%2F2019%2F07%2F03%2Fjavascript%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言最近在回顾之前学习的知识，打算把自己复习的这些知识的记录下来，也是一个加强记忆的过程 javascript基本数据类型javascript中有基本数据类型和复杂（引用）数据类型,基本数据类型包括Undefined,Number,String,Number,Boolean,Null,Symbol(ES6新增,表示独一无二的值)，引用类型统称Object对象,主要包括对象，函数和数组。这里只回顾基本数据类型。 NumberNumber表示数值类型，包括整数和浮点数。 NaNNaN是一个特殊的数值，表示非数值。其主要有两个规则1.任何涉及NaN的操作，都会返回NaN。2.NaN与任何值都不相等，包括它自身。isNaN是用来检测参数是否为非数值,返回值为Boolean,在检测时，会先尝试将参数转换为数值，在进行判断。 数值转换数制转换主要有三个函数Number(),ParseInt(),ParseFloat()。其中Number为强制转换。ParseInt()则是将参数转换为整数，第一个参数为需要转换的值，必须以数字开头才能转换，第二个参数为进制。转换为空字符串时为NaN。parserFloat()转换为浮点数。 StringString表示字符串类型,用双引号或者单引号都可以表示字符串。 String转换toSting()和String()都可以进行转换，其中String()的语法与Number()类似，都是强制转换。toString的语法为str.toString(),str为要转换的值。 BooleanBoolean只有两个值，true和false，表示真和假。 Boolean转换规则1.除0以外的所有数字，转换后都为true。2.除””字符串以外，转换后都为true。3.null和undefined转换后都为false。 javascript操作符基本操作符加减乘除就不用在赘述了，在使用时注意，其会将字符串隐式转换为数值 a++和++a的区别a++和++a都是递增的意思，不同之处在于a++会先返回原值，在返回递增之后的值。++a直接返回递增后的值 比较操作符== 操作符是比较值，但不比较类型。===则不但比较值，还会比较类型 三元操作符条件? 执行代码1 : 执行代码2 当条件为真时执行代码1,为假时执行代码2 逻辑操作符&amp;&amp;&amp;&amp;表示’与’,只有当条件都为真时，才为真，有一个为假，都为假。但其不一定返回值都为Boolean，以下为不是Boolean的规则1.当第一个条件转换为真时,返回第二个值。2.有一个条件为NaN时，返回NaN。3.有一个条件为null时，返回null。4.有一个条件为undefined时，返回undefined。5.当同时具有NaN,null,undefined，谁在前返回谁。 ||||表示或操作，只要有一个为真就为真。其不是Boolean的规则与&amp;&amp;相反 ！表示非，即取反的意思。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript基本类型和操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决hexo部分图片加载]]></title>
    <url>%2F2019%2F06%2F29%2F%E8%A7%A3%E5%86%B3hexo%E9%83%A8%E5%88%86%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前言昨天在上传博客图片时遇到了一个很神奇的问题，部分图片加载，部分不加载。上网搜索发现好像大家都是全部加载不出来，下个插件解决。这与我遇到的问题不太一样，于是开始了自己推测解决问题的历程。 猜测一(自己本地缓存没有清理干净)因为我一般上传博客不习惯用hexo clean清理一下(懒),猜测可能由于自己没有清理干净，导致上传的时候冲突，才无法显示。清理掉本地缓存后，接着上传，还是无法显示。—–失败 猜测二(上传路径不对)觉得是自己的路径不会，导致浏览器无法找到图片，按F12后发现果然浏览器报404错误—开心，找到问题所在了，于是去自己的github仓库查看，发现编译过后的html文件路径没有错误，并且图片也都在所属的文件内。—–失败 猜测三(图片自身格式问题)因为自己的问题是部分图片未加载,而唯一加载的那一张是我自己画的png格式的图,未加载的图片是我电脑截屏的png格式的图,于是自己从网上下了一张png格式的图,自己在本地又截了一张，上传，刷新，果然下载的图片可以显示,而截图无法显示。找到问题十分开心，可是该怎么解决，仔细看自己的代码发现所有jpg格式的图片都可以显示,于是自己将所有的电脑截屏的图片改为了jpg格式的，上传，刷新，成功显示—-完结撒花 小结解决完问题后，百度了一下两种图片有什么区别,简言之就是png格式的图片占据空间大，是无损压缩，而jpg格式的图片是有损压缩，是最适合在万维网上传输和存储的图片格式。]]></content>
      <categories>
        <category>日常问题</category>
      </categories>
      <tags>
        <tag>hexo图片加载问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex弹性布局 三]]></title>
    <url>%2F2019%2F06%2F28%2Fflex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[justify (设置每个元素在主轴上的对齐方式)它有五个值分别为flex-start(默认,左对齐),flex-end(右对齐),center(居中)space-between和space-around。一定注意该属性是设置主轴的对齐方式,因为默认的主轴为水平,所以下列代码测试图都为水平主轴，当其主轴为其他方向时，对齐方式类似，当设置纵轴为主轴时，一定要设置一个给定高度，否则无法看出效果。以下为测试代码截图:justify-content : flex-end justify-content : centerjustify-content : space-betweenjustify-content : space-around]]></content>
      <categories>
        <category>flex</category>
      </categories>
      <tags>
        <tag>flex布局之justify-content</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex弹性布局 二]]></title>
    <url>%2F2019%2F06%2F28%2Fflex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[flex-wrap (控制元素换行)它有三个值分别为nowrap(默认,不换行),wrap(换行),wrap-reverse(逆向换行)在测试换行时注意将外层的container的width设置的小于内部元素的总宽度，这样才会换行。以下为测试代码截图:flex-wrap : nowrap flex-wrap : wrapflex-wrap : wrap-reverse]]></content>
      <categories>
        <category>flex</category>
      </categories>
      <tags>
        <tag>flex布局之flex-wrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex弹性布局 一]]></title>
    <url>%2F2019%2F06%2F28%2Fflex%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[flex弹性盒模型flex弹性盒模型图如下 其分为容器container,内部项目(元素)flex item,主轴(默认为水平方向),交叉轴(纵轴)设置盒子为弹性盒子，只需要设置display:flex即可,接下来看一下如何控制弹性盒子， flex direction (控制元素的排列方向)它有四个值分别为row(默认,水平),row-reverse(逆水平),column(纵轴),column-reverse(逆纵轴)以下为测试代码截图:flex-direction : row flex-direction : row-reverse flex-direction : columnflex-direction : column-reverse]]></content>
      <categories>
        <category>flex</category>
      </categories>
      <tags>
        <tag>flex布局之flex-direction</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的let和const命令]]></title>
    <url>%2F2019%2F05%2F29%2FES6%E7%9A%84let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[let命令ES6新增了let命令,其作用类似于var，都是用来声明变量的,但既然有了var,为什么还要有let呢,以下为let的详解。 不允许重复声明在ES5中，你可以这样写,并不会报错,最终打印20. 123var i = 10;var i = 20;console.log(i); // 20 但用let声明时就不允许这样，这是因为let不允许在相同作用域重复声明一个变量。 12345 //报错function() &#123; let i = 10; var i = 20;&#125; 基于这个特性,其不允许在函数内部重新声明参数 1234//报错function test(a) &#123; let a = 10;&#125; 块级作用域let声明的变量在块级作用域内有效,所谓块级作用域，通俗来说就是{}包括的区域。但是var并没有块级作用域的概念 12345678&#123; let i = 10;&#125;console.log(i); //报错&#123; var i = 10;&#125;console.log(i) // 10 针对这个特性它可以很好的解决for循环变量的问题 1234567var a = [];for(var i = 0; i &lt; 10 ; i++)&#123; a[i] = function() &#123; console.log(i); &#125;&#125;a[5](); //10 打印出的结果并不是我们想要的5，这是因为i是var声明的，在全局范围内有效，每一次循环i都会发生变化,导致最终输出为10;但是使用let声明，变量只在块级作用域内有效 1234567var a = [];for(let i = 0; i &lt; 10 ; i++)&#123; a[i] = function() &#123; console.log(i); &#125;&#125;a[5](); //5 不存在变量提升变量提升即变量可以在声明之前使用，使用var声明的变量存在变量提升. 12console.log(i); //undefinedvar i = 10; 以上代码相当于 123var i; //undefinedconsole.log(i); //undefinedi = 10; 但let则不存在变量提升 12console.log(i); //报错let i = 10; 暂存性死区在作用域内，使用let声明变量之前，变量都是不可用的，这种语法称为暂存性死区。它跟不允许变量提升类似，就是为了防止在变量声明前，使用变量。 const命令const命令是用来声明一个不可变的常量，声明的常量只可读，不可以改变，所以使用const声明时，必须进行初始化，否则其会报错 1const i; //报错 const命令的其他用法与let相同。块级作用域,暂存性死区,不允许变量提升。但是否const命令声明的值就一定不可变呢，这里就要理解一下const命令的本质，const命令的本质是指向的那个内存地址不变，对于简单变量来说，值就保存在变量指向的内存地址中，所以不可变。但对于复杂数据类型(数组，对象),变量指向的内存是一个指针，他只能保证指向的地址不变，但不能保证里面的内容不变。可以这么理解，就是家庭住址是固定不变的，但家里的人和别的事物都是可以改变的。 平常用法选择声明变量时时let,常量时用const，尽量不使用var，防止污染作用域.]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>let和const命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站那些事]]></title>
    <url>%2F2019%2F05%2F28%2F%E5%BB%BA%E7%AB%99%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[关于本站为什么建站这个寒假就有建立一个自己博客的想法，觉得可以在自己的博客上写一些东西，是一件很cool的事情。但为了恶补前端的知识，就暂时搁置了这个想法，一门心思的专心于前端三剑客(HTML,CSS,JavaScript)的学习，现在也算把基础知识都过了一遍，就决定来建立自己的个人博客，记录一下自己的日常感想(性格使然，遇见事情，总忍不住联想感叹)和学习前端时所碰到的有趣的知识(写文章时也是对知识的一个回顾)。 怎么建站有了想法就得开始行动(百度)起来了，看了各种组合搭配，最终还是选择了Hexo和github的方式，至于为什么选择这种方式，一个字”穷”,毕竟这种方式免费，还能顺带学习一下git命令,一举两得。选定了方式，就要开始选择自己博客的主题了，于是就去Hexo的主题商店里挑选自己喜欢的主题，看来看去都觉得不符合自己的心意，恰巧在浏览别人博客时发现了一个十分简洁的主题next(就是你了)。然后就按网上的流程开始了自己的建站之旅，细节这里我就不过多赘述了，毕竟网上大佬总结的很详细，按着一步一步来，一般不会出啥大问题，但小问题肯定是会有的，毕竟每个人的配置和环境都有所不同，这时候就要发挥百度的神奇力量了，打开百度，输入你的问题，你就能收获各种各样的解答。解决掉几个小的问题后，总算是把自己的博客搭起来了，在输入域名弹出来自己博客的那一刻，觉得自己的努力没有白费，小有收获。 关于本人自我介绍长安大学的一名计算机大三学生，自我感觉良好，其实是个菜鸡。大学前两年混着混着，就到了该找工作步入社会的阶段了。回想起前两年的大学经历，甚是遗憾——没有仔细钻研编程，现在才幡然醒悟，开始恶补。所幸有着点基础，现在学起来，才没有那么吃力，也慢慢通过前端找到了写代码的乐趣，毕竟以前就是单纯的逻辑，对着黑乎乎的操作窗口实在是提不起什么兴趣，而前端则能让我实实在在的看见我写的东西。每学到新的知识，就意味着自己可以使用更多的方法去实现更好的网页，自然也对前端慢慢地有了兴趣。 短期目标最近的目标还是好好学习前端的知识，准备迎接即将到来的秋招。希望自己能在秋招中找到一份好的工作，开始自己的另一种生活。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
</search>
